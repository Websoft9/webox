# Websoft9 开发规范

## 1. 概述

### 1.1 目的

本文档旨在为 Websoft9 项目的开发团队提供统一的开发规范和最佳实践，确保代码质量、项目可维护性和团队协作效率。

### 1.2 适用范围

本规范适用于 Websoft9 平台的所有开发工作，包括：

- Websoft9 Web Service（后端服务）
- Websoft9 Web UI（前端界面）
- Websoft9 Agent（客户端程序）
- Websoft9 Gateway Service（网关服务）

### 1.3 技术栈概览

详见架构设计相关文档。

## 2. 技术规范

### 2.1 后端开发规范（Go）

#### 2.1.1 项目结构

```text
api-service/
├── cmd/                    # 应用程序入口
│   └── server/
│       └── main.go
├── internal/              # 私有应用程序代码
│   ├── controller/        # API 路由和处理器
│   ├── service/           # 业务逻辑层
│   ├── repository/        # 数据访问层
│   ├── model/             # 数据模型
│   ├── middleware/        # 中间件
│   └── config/            # 配置管理
├── pkg/                   # 可被外部应用使用的库代码
├── api/                   # API 定义文件（OpenAPI/Swagger）
├── configs/               # 配置文件模板
├── deployments/           # 部署相关文件
├── docs/                  # 项目文档
├── scripts/               # 构建、安装、分析等脚本
├── test/                  # 额外的外部测试应用和测试数据
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

#### 2.1.2 编码规范

**命名规范**

- 包名：小写，简短，有意义的名词
- 变量名：驼峰命名法，首字母小写
- 常量名：全大写，下划线分隔
- 函数名：驼峰命名法，首字母大写（公开）或小写（私有）
- 结构体：驼峰命名法，首字母大写

```go
// 正确示例
package user

const (
    DefaultTimeout = 30 * time.Second
    MaxRetryCount  = 3
)

type UserService struct {
    repo UserRepository
}

func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) {
    // 实现逻辑
}
```

**错误处理**

- 使用标准的 error 接口
- 错误信息应该清晰、具体
- 使用 errors.Wrap 添加上下文信息

```go
import "github.com/pkg/errors"

func (s *UserService) GetUser(id int64) (*User, error) {
    user, err := s.repo.FindByID(id)
    if err != nil {
        return nil, errors.Wrapf(err, "failed to get user with id %d", id)
    }
    return user, nil
}
```

**日志规范**

- 使用结构化日志（推荐 logrus 或 zap）
- 日志级别：DEBUG、INFO、WARN、ERROR、FATAL
- 包含必要的上下文信息

```go
import "github.com/sirupsen/logrus"

func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) {
    logger := logrus.WithFields(logrus.Fields{
        "operation": "CreateUser",
        "username":  req.Username,
    })
    
    logger.Info("Creating new user")
    
    user, err := s.repo.Create(req)
    if err != nil {
        logger.WithError(err).Error("Failed to create user")
        return nil, err
    }
    
    logger.WithField("user_id", user.ID).Info("User created successfully")
    return user, nil
}
```

#### 2.1.3 API 设计规范

**RESTful API 设计**

- 使用标准 HTTP 方法：GET、POST、PUT、DELETE、PATCH
- URL 设计遵循 RESTful 原则
- 使用合适的 HTTP 状态码

```go
// 路由定义示例
func SetupRoutes(r *gin.Engine) {
    api := r.Group("/api/v1")
    {
        users := api.Group("/users")
        {
            users.GET("", userHandler.ListUsers)           // GET /api/v1/users
            users.POST("", userHandler.CreateUser)         // POST /api/v1/users
            users.GET("/:id", userHandler.GetUser)         // GET /api/v1/users/:id
            users.PUT("/:id", userHandler.UpdateUser)      // PUT /api/v1/users/:id
            users.DELETE("/:id", userHandler.DeleteUser)   // DELETE /api/v1/users/:id
        }
    }
}
```

**响应格式标准化**

```go
type APIResponse struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
}

type PaginatedResponse struct {
    APIResponse
    Pagination *PaginationInfo `json:"pagination,omitempty"`
}

type PaginationInfo struct {
    Page       int   `json:"page"`
    PageSize   int   `json:"page_size"`
    Total      int64 `json:"total"`
    TotalPages int   `json:"total_pages"`
}
```

#### 2.1.4 数据库规范

**GORM 使用规范**

```go
type User struct {
    ID        uint      `gorm:"primarykey" json:"id"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
    
    Username string `gorm:"uniqueIndex;size:50;not null" json:"username"`
    Email    string `gorm:"uniqueIndex;size:100;not null" json:"email"`
    Password string `gorm:"size:255;not null" json:"-"`
    Status   int    `gorm:"default:1" json:"status"`
}

// 表名
func (User) TableName() string {
    return "users"
}
```

**数据库迁移**

- 使用 GORM AutoMigrate 进行开发环境迁移
- 生产环境使用专门的迁移脚本
- 所有迁移操作必须可回滚

### 2.2 前端开发规范（Vue 3）

#### 2.2.1 项目结构

```text
websoft9-web-ui/
├── public/                 # 静态资源
├── src/
│   ├── api/               # API 接口定义
│   ├── assets/            # 资源文件
│   ├── components/        # 公共组件
│   ├── composables/       # 组合式函数
│   ├── layouts/           # 布局组件
│   ├── pages/             # 页面组件
│   ├── router/            # 路由配置
│   ├── stores/            # Pinia 状态管理
│   ├── styles/            # 样式文件
│   ├── types/             # TypeScript 类型定义
│   ├── utils/             # 工具函数
│   ├── App.vue
│   └── main.ts
├── tests/                 # 测试文件
├── package.json
├── vite.config.ts
├── tsconfig.json
└── README.md
```

#### 2.2.2 编码规范

**组件命名**

- 组件文件名使用 PascalCase
- 组件在模板中使用 kebab-case

```vue
<!-- UserProfile.vue -->
<template>
  <div class="user-profile">
    <user-avatar :user="user" />
    <user-info :user="user" />
  </div>
</template>

<script setup lang="ts">
import UserAvatar from './UserAvatar.vue'
import UserInfo from './UserInfo.vue'

interface Props {
  user: User
}

defineProps<Props>()
</script>
```

**Composition API 使用**

```vue
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useUserStore } from '@/stores/user'

// 响应式数据
const loading = ref(false)
const users = ref<User[]>([])

// 计算属性
const activeUsers = computed(() => 
  users.value.filter(user => user.status === 1)
)

// 生命周期
onMounted(async () => {
  await fetchUsers()
})

// 方法
const fetchUsers = async () => {
  loading.value = true
  try {
    const response = await userApi.getUsers()
    users.value = response.data
  } catch (error) {
    console.error('Failed to fetch users:', error)
  } finally {
    loading.value = false
  }
}
</script>
```

**状态管理（Pinia）**

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { User } from '@/types/user'

export const useUserStore = defineStore('user', () => {
  // 状态
  const currentUser = ref<User | null>(null)
  const users = ref<User[]>([])

  // 计算属性
  const isLoggedIn = computed(() => currentUser.value !== null)

  // 方法
  const setCurrentUser = (user: User) => {
    currentUser.value = user
  }

  const logout = () => {
    currentUser.value = null
  }

  return {
    currentUser,
    users,
    isLoggedIn,
    setCurrentUser,
    logout
  }
})
```

#### 2.2.3 样式规范

**CSS 类命名**

- 使用 BEM 命名方法论
- 使用 kebab-case

```scss
// 正确示例
.user-profile {
  &__header {
    display: flex;
    align-items: center;
    
    &--compact {
      padding: 8px;
    }
  }
  
  &__avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
  }
  
  &__info {
    margin-left: 16px;
  }
}
```

**响应式设计**

```scss
// 断点定义
$breakpoints: (
  'mobile': 768px,
  'tablet': 1024px,
  'desktop': 1200px
);

@mixin respond-to($breakpoint) {
  @media (min-width: map-get($breakpoints, $breakpoint)) {
    @content;
  }
}

// 使用示例
.user-profile {
  padding: 16px;
  
  @include respond-to('tablet') {
    padding: 24px;
  }
  
  @include respond-to('desktop') {
    padding: 32px;
  }
}
```

### 2.3 客户端开发规范（Go Agent）

#### 2.3.1 项目结构

```text
websoft9-agent/
├── cmd/
│   └── agent/
│       └── main.go
├── internal/
│   ├── agent/             # Agent 核心逻辑
│   ├── monitor/           # 监控模块
│   ├── task/              # 任务执行模块
│   ├── workflow/          # 工作流模块
│   └── communication/     # 通信模块
├── pkg/
├── proto/                 # gRPC 协议定义
├── configs/
├── scripts/
└── README.md
```

#### 2.3.2 gRPC 服务定义

```protobuf
// proto/agent.proto
syntax = "proto3";

package agent;

option go_package = "github.com/websoft9/agent/proto";

service AgentService {
  rpc ExecuteTask(TaskRequest) returns (TaskResponse);
  rpc GetSystemInfo(SystemInfoRequest) returns (SystemInfoResponse);
  rpc SendHeartbeat(HeartbeatRequest) returns (HeartbeatResponse);
}

message TaskRequest {
  string task_id = 1;
  string task_type = 2;
  string payload = 3;
  int64 timeout = 4;
}

message TaskResponse {
  string task_id = 1;
  bool success = 2;
  string message = 3;
  string result = 4;
}
```

## 3. 代码规范

### 3.1 通用代码规范

#### 3.1.1 注释规范

**Go 注释**

```go
// Package user provides user management functionality.
package user

// UserService handles user-related business logic.
type UserService struct {
    repo UserRepository
}

// CreateUser creates a new user with the given information.
// It returns the created user or an error if the operation fails.
func (s *UserService) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) {
    // Validate input parameters
    if err := s.validateCreateUserRequest(req); err != nil {
        return nil, errors.Wrap(err, "invalid create user request")
    }
    
    // Create user in database
    user, err := s.repo.Create(ctx, req)
    if err != nil {
        return nil, errors.Wrap(err, "failed to create user in database")
    }
    
    return user, nil
}
```

**Vue/TypeScript 注释**

```typescript
/**
 * 用户管理相关的 API 接口
 */
export class UserApi {
  /**
   * 获取用户列表
   * @param params 查询参数
   * @returns 用户列表响应
   */
  async getUsers(params: GetUsersParams): Promise<ApiResponse<User[]>> {
    const response = await http.get('/api/v1/users', { params })
    return response.data
  }
  
  /**
   * 创建新用户
   * @param userData 用户数据
   * @returns 创建的用户信息
   */
  async createUser(userData: CreateUserData): Promise<ApiResponse<User>> {
    const response = await http.post('/api/v1/users', userData)
    return response.data
  }
}
```

#### 3.1.2 代码格式化

**Go 代码格式化**

- 使用 `gofmt` 或 `goimports` 格式化代码
- 使用 `golangci-lint` 进行代码检查

```bash
# 格式化代码
goimports -w .

# 代码检查
golangci-lint run
```

**前端代码格式化**

- 使用 Prettier 格式化代码
- 使用 ESLint 进行代码检查

```json
// .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

### 3.2 代码质量要求

#### 3.2.1 代码复杂度

- 单个函数不超过 100 行
- 圈复杂度不超过 10
- 嵌套层级不超过 4 层

#### 3.2.2 性能要求

**后端性能**

- API 响应时间 < 200ms（95%）
- 数据库查询优化，避免 N+1 问题
- 合理使用缓存

**前端性能**

- 首屏加载时间 < 2s
- 路由懒加载
- 图片懒加载和压缩

## 4. 版本控制规范

### 4.1 Git 工作流

采用 **Git Flow** 工作流模型：

```text
main (生产分支)
├── develop (开发分支)
├── release/v1.2.0 (发布分支)
└── hotfix/critical-bug-fix (修复分支)
```

### 4.2 分支命名规范

| 分支类型 | 命名格式 | 示例 |
|----------|----------|------|
| 开发分支 | `develop/版本号` | `develop/v1.2.1` |
| 修复分支 | `hotfix/问题描述` | `hotfix/login-error-handling` |
| 发布分支 | `release/版本号` | `release/v1.2.0` |

### 4.3 提交信息规范

使用 **Conventional Commits** 规范：

```text
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

**提交类型**

- `feat`: 新功能
- `fix`: 修复 bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

**示例**

```text
feat(auth): add JWT token refresh mechanism

- Implement automatic token refresh
- Add refresh token storage
- Handle token expiration gracefully

Closes #123
```

### 4.4 代码审查规范

#### 4.4.1 Pull Request 要求

- PR 标题清晰描述变更内容
- 包含详细的变更说明
- 关联相关的 Issue
- 通过所有自动化测试
- 至少一个团队成员审查通过

#### 4.4.2 审查检查清单

**功能性检查**

- [ ] 功能是否按需求正确实现
- [ ] 边界条件是否正确处理
- [ ] 错误处理是否完善

**代码质量检查**

- [ ] 代码是否符合规范
- [ ] 是否有重复代码
- [ ] 变量和函数命名是否清晰
- [ ] 注释是否充分

**安全性检查**

- [ ] 是否存在安全漏洞
- [ ] 敏感信息是否正确处理
- [ ] 输入验证是否充分

## 5. 测试规范

### 5.1 测试策略

采用测试金字塔模型：

```
    /\
   /  \  E2E Tests (10%)
  /____\
 /      \
/        \ Integration Tests (20%)
\________/
\        /
 \______/ Unit Tests (70%)
```

### 5.2 单元测试规范

#### 5.2.1 Go 单元测试

```go
// user_service_test.go
package user

import (
    "context"
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

func TestUserService_CreateUser(t *testing.T) {
    tests := []struct {
        name    string
        request *CreateUserRequest
        setup   func(*MockUserRepository)
        want    *User
        wantErr bool
    }{
        {
            name: "successful user creation",
            request: &CreateUserRequest{
                Username: "testuser",
                Email:    "test@example.com",
                Password: "password123",
            },
            setup: func(repo *MockUserRepository) {
                repo.On("Create", mock.Anything, mock.Anything).
                    Return(&User{ID: 1, Username: "testuser"}, nil)
            },
            want: &User{ID: 1, Username: "testuser"},
            wantErr: false,
        },
        {
            name: "invalid email format",
            request: &CreateUserRequest{
                Username: "testuser",
                Email:    "invalid-email",
                Password: "password123",
            },
            setup: func(repo *MockUserRepository) {},
            want: nil,
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            repo := &MockUserRepository{}
            tt.setup(repo)
            
            service := NewUserService(repo)
            got, err := service.CreateUser(context.Background(), tt.request)
            
            if tt.wantErr {
                assert.Error(t, err)
                assert.Nil(t, got)
            } else {
                assert.NoError(t, err)
                assert.Equal(t, tt.want, got)
            }
            
            repo.AssertExpectations(t)
        })
    }
}
```

#### 5.2.2 Vue 组件测试

```typescript
// UserProfile.test.ts
import { mount } from '@vue/test-utils'
import { describe, it, expect, vi } from 'vitest'
import UserProfile from '@/components/UserProfile.vue'

describe('UserProfile', () => {
  const mockUser = {
    id: 1,
    username: 'testuser',
    email: 'test@example.com',
    avatar: 'https://example.com/avatar.jpg'
  }

  it('renders user information correctly', () => {
    const wrapper = mount(UserProfile, {
      props: {
        user: mockUser
      }
    })

    expect(wrapper.find('.user-profile__username').text()).toBe('testuser')
    expect(wrapper.find('.user-profile__email').text()).toBe('test@example.com')
  })

  it('emits edit event when edit button is clicked', async () => {
    const wrapper = mount(UserProfile, {
      props: {
        user: mockUser
      }
    })

    await wrapper.find('.user-profile__edit-btn').trigger('click')
    
    expect(wrapper.emitted('edit')).toBeTruthy()
    expect(wrapper.emitted('edit')[0]).toEqual([mockUser])
  })
})
```

### 5.3 集成测试规范

#### 5.3.1 API 集成测试

```go
// integration_test.go
func TestUserAPI_Integration(t *testing.T) {
    // 设置测试数据库
    db := setupTestDB(t)
    defer cleanupTestDB(t, db)
    
    // 启动测试服务器
    server := setupTestServer(db)
    defer server.Close()
    
    client := &http.Client{}
    
    t.Run("create and get user", func(t *testing.T) {
        // 创建用户
        createReq := CreateUserRequest{
            Username: "testuser",
            Email:    "test@example.com",
            Password: "password123",
        }
        
        resp, err := client.Post(server.URL+"/api/v1/users", 
            "application/json", 
            strings.NewReader(toJSON(createReq)))
        
        assert.NoError(t, err)
        assert.Equal(t, http.StatusCreated, resp.StatusCode)
        
        var createResp APIResponse
        json.NewDecoder(resp.Body).Decode(&createResp)
        userID := createResp.Data.(map[string]interface{})["id"]
        
        // 获取用户
        resp, err = client.Get(fmt.Sprintf("%s/api/v1/users/%v", server.URL, userID))
        assert.NoError(t, err)
        assert.Equal(t, http.StatusOK, resp.StatusCode)
    })
}
```

### 5.4 端到端测试规范

使用 Playwright 进行 E2E 测试：

```typescript
// tests/e2e/user-management.spec.ts
import { test, expect } from '@playwright/test'

test.describe('User Management', () => {
  test.beforeEach(async ({ page }) => {
    // 登录系统
    await page.goto('/login')
    await page.fill('[data-testid="username"]', 'admin')
    await page.fill('[data-testid="password"]', 'password')
    await page.click('[data-testid="login-btn"]')
    await expect(page).toHaveURL('/dashboard')
  })

  test('should create new user successfully', async ({ page }) => {
    // 导航到用户管理页面
    await page.click('[data-testid="user-management-menu"]')
    await expect(page).toHaveURL('/users')
    
    // 点击创建用户按钮
    await page.click('[data-testid="create-user-btn"]')
    
    // 填写用户信息
    await page.fill('[data-testid="username-input"]', 'newuser')
    await page.fill('[data-testid="email-input"]', 'newuser@example.com')
    await page.fill('[data-testid="password-input"]', 'password123')
    
    // 提交表单
    await page.click('[data-testid="submit-btn"]')
    
    // 验证用户创建成功
    await expect(page.locator('[data-testid="success-message"]')).toBeVisible()
    await expect(page.locator('text=newuser')).toBeVisible()
  })
})
```

### 5.5 测试覆盖率要求

- 单元测试覆盖率 ≥ 80%
- 集成测试覆盖率 ≥ 60%
- 关键业务逻辑覆盖率 ≥ 90%

## 6. 发布管理规范

### 6.1 版本号规范

采用 **语义化版本控制（SemVer）**：

```text
MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]

例如：
1.0.0        # 正式版本
1.1.0-alpha  # 预发布版本
1.1.0-beta.1 # Beta 版本
1.1.0+20240731 # 带构建信息的版本
```

**版本号递增规则**

- MAJOR：不兼容的 API 修改
- MINOR：向下兼容的功能性新增
- PATCH：向下兼容的问题修正

### 6.2 发布流程

#### 6.2.1 开发环境发布

```bash
# 1. 代码合并到 develop 分支
git checkout develop
git merge feature/new-feature

# 2. 运行测试
make test

# 3. 构建镜像
make build-dev

# 4. 部署到开发环境
make deploy-dev
```

#### 6.2.2 测试环境发布

```bash
# 1. 创建发布分支
git checkout -b release/v1.2.0 develop

# 2. 更新版本号
echo "v1.2.0" > VERSION

# 3. 运行完整测试套件
make test-all

# 4. 构建测试版本
make build-staging

# 5. 部署到测试环境
make deploy-staging
```

#### 6.2.3 生产环境发布

```bash
# 1. 发布分支合并到 main
git checkout main
git merge release/v1.2.0

# 2. 创建发布标签
git tag -a v1.2.0 -m "Release version 1.2.0"

# 3. 构建生产版本
make build-prod

# 4. 部署到生产环境
make deploy-prod

# 5. 合并回 develop 分支
git checkout develop
git merge main
```

### 6.3 CI/CD 流水线

#### 6.3.1 GitHub Actions 配置

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.21
    
    - name: Run tests
      run: |
        go test -v -race -coverprofile=coverage.out ./...
        go tool cover -html=coverage.out -o coverage.html
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: |
        docker build -t websoft9/web-service:${{ github.sha }} .
    
    - name: Push to registry
      if: github.ref == 'refs/heads/main'
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker push websoft9/web-service:${{ github.sha }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Deploy to production
      run: |
        # 部署脚本
        echo "Deploying to production..."
```

### 6.4 回滚策略

#### 6.4.1 快速回滚

```bash
# 1. 回滚到上一个版本
kubectl rollout undo deployment/api-service

# 2. 或回滚到指定版本
kubectl rollout undo deployment/api-service --to-revision=2

# 3. 验证回滚状态
kubectl rollout status deployment/api-service
```

#### 6.4.2 数据库回滚

```bash
# 1. 停止应用服务
kubectl scale deployment/api-service --replicas=0

# 2. 恢复数据库备份
mysql -u root -p websoft9_db < backup_20240731.sql

# 3. 重启应用服务
kubectl scale deployment/api-service --replicas=3
```

## 7. 项目管理规范

### 7.1 需求管理

#### 7.1.1 需求文档模板

```markdown
# 需求标题

## 需求概述
简要描述需求的背景和目标

## 用户故事
作为 [用户角色]，我希望 [功能描述]，以便 [价值/目标]

## 验收标准
- [ ] 标准1
- [ ] 标准2
- [ ] 标准3

## 技术要求
- 性能要求
- 安全要求
- 兼容性要求

## 设计稿/原型
[链接或附件]

## 优先级
高/中/低

## 预估工时
X 人天
```

#### 7.1.2 需求评审流程

1. **需求提出** - 产品经理提出需求
2. **技术评审** - 技术团队评估可行性和工时
3. **需求确认** - 各方确认需求细节
4. **任务分解** - 将需求分解为具体任务
5. **开发排期** - 安排开发计划

### 7.2 任务管理

#### 7.2.1 任务分类

| 任务类型 | 标签 | 描述 |
|----------|------|------|
| 新功能 | `feature` | 新功能开发 |
| Bug修复 | `bug` | 问题修复 |
| 技术债务 | `tech-debt` | 代码重构、优化 |
| 文档 | `docs` | 文档编写和更新 |
| 测试 | `test` | 测试用例编写 |

#### 7.2.2 任务状态流转

```text
待办 → 进行中 → 代码审查 → 测试 → 完成
  ↓       ↓        ↓       ↓      ↓
 阻塞    阻塞     阻塞    阻塞   关闭
```

### 7.3 沟通协作

#### 7.3.1 会议规范

**每日站会**

- 时间：每天上午 9:30，15分钟
- 内容：昨天完成、今天计划、遇到问题
- 参与者：开发团队全员

**迭代规划会**

- 时间：每个迭代开始前
- 内容：确定迭代目标和任务分配
- 参与者：产品经理、技术负责人、开发团队

**迭代回顾会**

- 时间：每个迭代结束后
- 内容：总结经验教训，改进流程
- 参与者：全体团队成员

#### 7.3.2 文档管理

**技术文档**

- API 文档：使用 Swagger/OpenAPI/Aipfox
- 架构文档：使用 Markdown + 图表
- 部署文档：详细的部署和运维指南

**知识分享**

- 代码审查：每个 PR 必须审查
- 文档更新：功能开发同步更新文档

## 8. 安全规范

### 8.1 代码安全

#### 8.1.1 敏感信息处理

**配置管理**

```go
// 错误示例 - 硬编码敏感信息
const (
    DBPassword = "password123"
    APIKey     = "sk-1234567890abcdef"
)

// 正确示例 - 使用环境变量
type Config struct {
    DBPassword string `env:"DB_PASSWORD,required"`
    APIKey     string `env:"API_KEY,required"`
}
```

**密钥管理**

- 使用专门的密钥管理服务（如 HashiCorp Vault）
- 定期轮换密钥
- 最小权限原则

#### 8.1.2 输入验证

```go
// 输入验证示例
func (h *UserHandler) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
        return
    }
    
    // 验证输入
    if err := h.validator.Validate(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // 清理输入
    req.Username = strings.TrimSpace(req.Username)
    req.Email = strings.ToLower(strings.TrimSpace(req.Email))
    
    // 处理业务逻辑
    user, err := h.userService.CreateUser(c.Request.Context(), &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
        return
    }
    
    c.JSON(http.StatusCreated, gin.H{"data": user})
}
```

#### 8.1.3 SQL 注入防护

```go
// 错误示例 - 容易受到 SQL 注入攻击
query := fmt.Sprintf("SELECT * FROM users WHERE username = '%s'", username)
rows, err := db.Query(query)

// 正确示例 - 使用参数化查询
query := "SELECT * FROM users WHERE username = ?"
rows, err := db.Query(query, username)

// 使用 GORM（推荐）
var user User
db.Where("username = ?", username).First(&user)
```

### 8.2 API 安全

#### 8.2.1 认证和授权

```go
// JWT 中间件
func JWTAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authorization header"})
            c.Abort()
            return
        }
        
        // 验证 JWT token
        claims, err := validateJWTToken(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }
        
        // 设置用户信息到上下文
        c.Set("user_id", claims.UserID)
        c.Set("user_role", claims.Role)
        c.Next()
    }
}

// RBAC 权限检查
func RequirePermission(permission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userRole := c.GetString("user_role")
        if !hasPermission(userRole, permission) {
            c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
            c.Abort()
            return
        }
        c.Next()
    }
}
```

#### 8.2.2 API 限流

```go
// 限流中间件
func RateLimitMiddleware(limit int, window time.Duration) gin.HandlerFunc {
    limiter := rate.NewLimiter(rate.Every(window/time.Duration(limit)), limit)
    
    return func(c *gin.Context) {
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Rate limit exceeded",
            })
            c.Abort()
            return
        }
        c.Next()
    }
}
```

### 8.3 数据安全

#### 8.3.1 数据加密

```go
// 密码加密
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

func CheckPasswordHash(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// 敏感数据加密
func EncryptSensitiveData(data string, key []byte) (string, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return "", err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, []byte(data), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}
```

#### 8.3.2 数据备份

```bash
#!/bin/bash
# 数据库备份脚本

BACKUP_DIR="/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="websoft9_db"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行备份
mysqldump -u root -p$MYSQL_ROOT_PASSWORD $DB_NAME > $BACKUP_DIR/${DB_NAME}_${DATE}.sql

# 压缩备份文件
gzip $BACKUP_DIR/${DB_NAME}_${DATE}.sql

# 删除7天前的备份
find $BACKUP_DIR -name "*.sql.gz" -mtime +7 -delete

echo "Backup completed: ${DB_NAME}_${DATE}.sql.gz"
```

### 8.4 安全审计

#### 8.4.1 日志记录

```go
// 审计日志结构
type AuditLog struct {
    ID        uint      `json:"id"`
    UserID    uint      `json:"user_id"`
    Action    string    `json:"action"`
    Resource  string    `json:"resource"`
    IPAddress string    `json:"ip_address"`
    UserAgent string    `json:"user_agent"`
    Timestamp time.Time `json:"timestamp"`
    Details   string    `json:"details"`
}

// 记录审计日志
func LogAuditEvent(userID uint, action, resource, ipAddress, userAgent, details string) {
    auditLog := AuditLog{
        UserID:    userID,
        Action:    action,
        Resource:  resource,
        IPAddress: ipAddress,
        UserAgent: userAgent,
        Timestamp: time.Now(),
        Details:   details,
    }
    
    // 保存到数据库
    db.Create(&auditLog)
    
    // 同时记录到日志文件
    logrus.WithFields(logrus.Fields{
        "user_id":    userID,
        "action":     action,
        "resource":   resource,
        "ip_address": ipAddress,
        "details":    details,
    }).Info("Audit event recorded")
}
```

#### 8.4.2 安全扫描

```yaml
# .github/workflows/security.yml
name: Security Scan

on:
  push:
    branches: [ main, develop ]
  schedule:
    - cron: '0 2 * * *'  # 每天凌晨2点运行

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Run Gosec Security Scanner
      uses: securecodewarrior/github-action-gosec@master
      with:
        args: './...'
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
```
